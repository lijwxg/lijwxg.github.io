---
title: "JavaScript笔记"
date: "2020-02-29"
tags:
  - javascript
  - basic
---

> JavaScript 是 EMCA 标准的实现, 各个厂商的实现是有区别的

<!--more-->

## ECMA

> JavaScript 的标准, 由欧洲计算机制造商协会推出

## DOM

> 文档对象模型

## BOM

> 浏览器对象模型

## javascript 初级

### js 的位置

1. 可以将 js 代码编写到标签的 onclick 属性中, 也可以现在写在 a 标签的 href 中等
1. 可以将 js 代码编写在 script 标签中, type 属性为 text/javascript
1. 还可以将 js 代码写在单独的文件, 通过 script 标签的 src 属性导入

### js 的执行

1. js 是逐行执行
1. 如果 script 标签使用了 src, 那么该标签下的内容将不在执行

### js 基本语法

1.  注释: 注释中内容不会被执行, 但是可以在源代码中查看.
    - 多行注释: /_ 多行注释 _/
    - 单行注释: // 单行注释
1.  js 中是严格区分大小写的, 在 html 中是不严格区分的.
1.  js 中每一条语句以分号结尾, 如果不写分号, 浏览器会自动添加, 但是会消耗一些性能, 而且有些时候, 浏览器会加错分号(由于没有分号, 解析错了语义)
1.  js 中会忽略多个空格和换行, 所以我们可以利用空格和换行进行一个格式美化
1.  常量: 数字, 字符, 字符串
1.  变量, 可以用来保存常量
    - 声明变量: let, const
    - 变量名:
      - 使用包含字符, 数字, \_, \$这些字符
      - 变量名不能以数字开头
      - 变量名不能和保留字, 关键词一样
      - 变量名使用驼峰法命名
      - 注意: js 变量实际上是采用 Unicode 编码, 凡是 Unicode 编码其实都是可以用来作为变量名
1.  六种数据类型:
    - String, 使用一对引号引起来, 可以使用\对特殊字符进行转义
    - Number, 在 js 中所有的数值都是 Number 类型, 包含整数和浮点数.
      - 其中 Infinity 表示无穷大,是一个值
      - 其中 NaN 是一个特殊的数字, 表示不是一个数字(Not a Number)
      - Number.MAX_VALUE, Number.MIN_VALUE
      - 在 js 中整数的运算基本是可以保证精确的
      - 如果使用 js 进行浮点数运算就会出现精度问题
      - 其中以 0x 开头的是 16 进制
      - 以 0 开头的是 8 进制
      - 以 0b 开头的事 2 进制
    - Boolean: 做逻辑判断
      - true
      - false
    - Null: 就一个 null 值, 专门用来表示一个为空的对象
    - Undefined: 只有一个值 undefined, 当一个变量声明了,但是没有赋值
    - Object: 对象
      > 其中 Object 属于引用数据类型
1.  强制类型转换
    - 将其他数据类型转化 String
      - 方式一: 调用被转化数据类型的 toString()方法
        - 该方法不会影响原变量, 他会将转化的结果返回
        - 但是注意 null, undefined, 没有 toString()方法, 如果调用,会报错
      - 方式二: 调用 String()函数, 来转化为字符串
        - 对于 Number, Boolean, 就是调用 toString()方法
        - 对于 Null, Undefined, 则是返回字面值
    - 将其它的数据类型转化为 Number
      使用 Number()方法, 来转化为数值
      - 如果是纯数字的字符串, 则将其转化为数字
      - 如果字符串中有非数字的内容, 则转化为 NaN
      - 如果字符串是一个空串, 或者一个全是空格的字符串, 则转化为 0
      - 如果是布尔型, 而 true 是 1, false 是 0
      - 如果是 null, 则是 0
      - 如果是 undefined ,则是 NaN
        使用 parseInt(), parseFloat()作为方法进行转化
      - 提取字符串中的数值类型
      - 只对已数字开头的字符串有效
    - 将其它的类型转化为布尔类
      使用 Boolean()函数来转化
      - 数字转化为布尔: 除了 0 和 NaN 其余都是 true
      - 字符串转化布尔: 除了带空格的字符串其余都是 true(包含)
1.  运算符
    通过预算符可以对一个或者多个值进行运算,并获取运算结果
    typeof, 获得一个值得类型 - 返回数据的类型, 作为字符串
    '+'加号: 运算是从左往右运算 - 可以做数值运算 - 任何值和数字相加都会转化为 Number 在运算(除了字符串的加法) - 任何值和 NaN 做运算都是 NaN - 可以连接字符串, 可以连接多行字符串, 任何值和字符串相加都会转化为字符串在相加 - 注意: 任何值和字符串相加都要先把值转化为字符串再相加
    '-'减号 - 可以对两个值进行减法运算
    '_'乘号, 乘法
    '/'除号
    '%'号, 取模
    任何值和- _ /做运算的时候都会自动转化为 Number - 可以利用这个特点做隐式的类型转换

    一元运算符: 只需要一个操作符
    '+'正号, 可以对其它的数据类型进行隐式转化, 和 Number()的原理一样
    '-'负号, 可以将其它的数据类型转化为 Number,再取负
    逻辑运算符
    对于非布尔值得运算, 则先将值转化为布尔值进行运算,最后返回原值, 返回最后一个接受运算的值
    '||'或, 或运算是找 true - 两个值中只要有一个为 true, 则返回 true - js 中的||是短路的, 第一个值是 true 则返回 true, 不再继续执行
    '&&'与, 与运算是找 false - 两个值中只要有一个为 false, 则返回 false - js 中的&&是短路的: 第一个值为 false 则返回 false, 不再继续执行
    '!'非 - 对一个变量进行非运算, 则会将其转化为 - 可以为任意一个数据类型做两次非运算, 则会将其转化布尔值
    比较运算
    '>'大于号
    '<'小于号
    '='等于号
    如果是两个字符串进行比较: 则是一位一位进行对比. 转化为 Unicode 码进行比较
    注意: 如果在比较两个字符串的数字的时候, 可能得到不可预期的结果, 需要进行数据类型转化
    相等运算
    '==', 判断两个值是否相等, 返回 boolean - 当使用==进行比较时, 如果两者类型不同,则会进行隐式类型转化, 再进行比较. 一般是转化为数字比较

             - null == 0 //false
             - undefined衍生自null
             - undefined == null //true

             - NaN不与任何值相等, 包括NaN自己, 使用isNaN()函数判断
         '!=', 不等, 和==类似, 结果相反
         '===', 全等, 不进行隐式类型转化
         '!==', 不全等, 和全等类似

    三元运算符, 也叫条件运算符.
    语法: 条件表达式?语句 1:语句 2
    执行流程 - 如果该值为 true, 则执行语句 1, 并返回结果 - 如果该值为 false, 则执行语句 2, 并返回结果
    ',' 运算符, 使用 ','可以分割多个语句, 一般在声明多个变量时使用

    运算符的优先级
    js 优先级运算表
    与优先级比或高

1.  代码块
    使用{}来分割代码块, 并不是隔离
1.  流程控制语句
    js 中程序是从上往下, 逐行执行

    1. 条件判断语句
       if(条件表达式){

       } else{

       }.

    1. 选择执行
       switch(选择值){
       case 值:
       default:
       } .
       - 全等比较
       - 在执行完一个分支之后, 使用 break;跳出
       - 如果所有的判断都是 false, 则执行 default
    1. 循环执行
       while(条件判断){
       语句...
       }

       do{

       } while {

       }

       for 循环

       - do while 是执行方法 ,再判断, while 是先判断再执行
         break:
         可以为循环语句起个名字
         label:循环语句
         这样 break 就会结束指定的循环
         continue:
         continue 可以跳过当次循环

1.  对象
    对象属于一种符合的数据类型, 在对象中可以保存多个不同数据类型的属性
    对象的分类: 1. 内建对象: - 由 ES 标准中定义的对象, 在任何的 ES 的实现中都可以使用 - 比如: Math String, Number, Boolean, Function 2. 宿主对象 - 由 JS 的运行环境提供的对象, 目前来讲主要是指有浏览器提供的对象 - 比如: BOM, DOM 3. 自定义对象: - 由开发人员自己定义的对象
    创建对象: 1. 使用 new 关键字调用的函数, 是构造函数 constructor 1. 构造函数是专门用来创建对象的函数 1. 使用 typeof 检查一个对象, 会返回 obect 1. 在对象中保存的值是属性 1. 使用.方法可以增改查属性 1. 使用 delete 方法可以删除属性 1. 对于特殊的属性名不能使用.的方式操作, 例如数字 - obj.123 是不行的 - 使用 obj['123']来操作属性 - 使用中括号来操作属性更加灵活, 在[]中可以使用变量 1. in 运算符
    使用 in 检查对象中是否有某个属性 1. 使用对象字面量创建一个对象, {}和 new Object()一致 - 可以在创建的时候给对象赋予属性 - 对象属性名可以加引号, 也可以不加 - 但是对于特殊的字符, 是需要加引号的
    创建函数对象:
    可以将要封装的代码以字符串的形式传递给构造函数. - 可以使用 new Function();来创建 - 使用函数声明来创建一个函数, 关键字 function - function fun2(){
    console.log("function!!!")
    } - 使用函数表达式创建: 匿名函数, 其实是创建一个匿名函数然后给它赋值给一个变量
    var 变量名 = function(){} - 立即执行函数, 使用圆括号把匿名函数包起来之后直接调用 - 方法, 对象的属性是函数, 则就是方法. 方法是一种特殊的属性.使用匿名函数作为属性
    对象的迭代:
    for in 语句遍历对象, 遍历得到的值是 key, 需要通过 key 获取 value.
1.  作用域
    作用域是一个变量的作用范围, 在 JS 中有两个作用域
    声明提前
    - 全局作用域
      - 直接编写在 script 中的 js 代码
      - 全局作用域在页面打开时候创建, 页面关闭的时候销毁
      - 在全局作用域中有一个全局对象 window, 十分特殊.
        - 它代表一个浏览器的窗口, 它由浏览器创建, 我们可以使用
      - 在全局作用域中
        - 创建的变量都会作为 window 对象的属性保存
        - 创建的函数都会作为 window 对象的方法保存
      - 全局作用域中的变量都是全局变量
        在页面的任意位置都可以访问到
    - 函数作用域
      - 调用函数时创建函数作用域, 函数执行完毕只有, 函数作用域销毁
      - 每调用一次函数, 就会创建一个新的函数作用域, 它们之间是互相独立的
      - 在函数作用域中, 可以访问到全局作用域的变量
      - 当在函数作用域操作一个变量时, 他会现在自身作用域中寻找, 如果有就直接使用
        - 如果没有则向上一级中寻找, 直到找到全局作用域为止
      - 函数会在所有的函数声明结束后开始执行
      - 在函数中不使用 let, const 声明的变量都会是全局变量, 使用声明则才会是函数变量
      - 定义形参就相当于在函数作用域中声明了变量
1.  this
    解释器在调用函数每次都会向内部传递一个隐含的参数
    这个隐含的参数就是 this, this 指向一个对象
    这个对象我们称为函数执行的上下文
    根据函数的执行方法不同, this 不同, this 指向了调用方法的对象
    - 以函数调用的时候 this 就是 window, 其实也就是 window 调用方法
    - 以方法调用时, this 就是对应对象
    - this 可以实现多态
1.  使用工厂方法创建对象
    - 提取大量重复待代码
1.  构造函数
    - 构造函数和普通函数不同在于调用方法不同.
    - 构造函数使用 new 调用
    - 构造函数的执行过程
      1. 立即创建一个新的对象
      1. 将新对象设置为函数的 this, 在构造函数中可以使用 this 来引用构建的对象
      1. 逐行执行函数中的代码
      1. 将新建的对象作为返回信息
    - 使用一个构造函数创建的对象, 我们称为一个类
      将函数定义在全局作用域, 会污染全局作用域的命名空间
1.  原型
    prototype
    我们做创建的每一个函数,解释器都会向函数中添加一个 prototype 属性
    这个属性对应着一个对象, 这个对象是我们所谓的原型对象
    如果我们函数是以普通函数调用, 那么 prototype 没有任何作用
    如果函数是构造函数的形式调用时, 它所创建的对象中会有一个隐含的属性
    这个属性指向该构造函数的原型对象, 我们可以通过**proto**来访问该属性
    原型对象就想当与一个公共的区域, 所有同一个类的实例都可以访问到这个原型对象属性
    我们可以将对象中共有的内容,设置到原型对象中
    以后我们在构建函数时, 可以将一些属性和方法都设置在原型中
    这样不会污染命名空间, 也能够正常使用
    **是继承的一种表现**

    检查属性:
    使用 in 检查, 如果在原型中也会返回 true
    使用 hasOwnProperty()方法判断时候只属于自身

        原型对象也是对象, 所以它也有原型.
        现在自身找, 如果有,则直接使用
        没有没有, 则去原型对象中寻找, 如果原型对象中有,则使用
        如果没有则去原型的原型中寻找, 知道找到Object对象的原型
        Object对象的原型没有原型, 如果Object中依然没有找到, 则返回undefined

1.  垃圾回收
    在 JS 中拥有自动的垃圾回收机制, 会自动将这些垃圾对象从内存中下回
    我们不需要进行垃圾回收的操作
    我们只需要将不需要的对象设置成 null

1.  数组
    let arry = new Array();
    数组表示已下标为索引的一组数据.
    数组的可以长度可以修改
    如果是指定下标则中间不存在的索引对应的值会自动填充为空
    使用中括号创建数组 - let arry = [] - 在创建的时候就可以向数组中添加元素 - 使用构造函数创建数组的时候, 也可以创建是添加元素 - 使用 Array(10)不能创建一个只有一个元素的数组, 表示创建一个长度为 10 的数组
    - push()方法
      - 添加元素
      - 在数组的末尾添加一个或者多个元素, 并返回数组的长度
      - 可以同时添加多个元素
    - pop()方法
      - 从数组中中删除最后一个元素, 并将删除的与元素作为返回值返回
    - unshift()方法
      - 向数组开头添加一个或者多个元素, 并返回新的数组长度
    - forEach()方法
      - 需要一个函数作为参数
        - 想这样有我们创建,但是不由我们调用的称为回调函数
        - 数组中有几个元素, 函数就会执行几次, 每次执行, 浏览器都会遍历数组中的元素
        - 以实参的形式传递, 我们可以来定义形参, 来读取这写内容
        - 浏览器会在回调中传递三个参数
          - 第一个参数: 就是当前正在遍历的元素
          - 第二个元素: 就是当前正在遍历的元素的索引
          - 第三个元素: 就是正在遍历的数组
    - slice()方法
      - 从某个已有的数组中返回指定的元素
      - 参数:
        1. 截取开始元素索引
        1. 截取结束元素索引(不包含)
           - 可以省略不写, 此时会截取从开始索引往后的所有元素
        - 可以使用负数
    - splice()方法
      - 可以用于删除数组中的指定元素
      - 使用 splice()方法会影响到源数组, 会将指定元素从原数组中删除, 并将被删除的元素作为返回值返回
      - 参数
        1. 开始位置的索引
        1. 表示删除的数量
        1. 第三个以后元素, 这些元素会自动插入到开始位置索引前面
    - contat()方法
      - 把数组进行拼接, 不会对源数组产生影响
    - join()方法
      - 把数组转为为字符串, 不会对源数组产生影响
      - join 默认使用逗号连接, 参数可以使用指定字符串连接
    - reverse()方法
      - 颠倒数组中元素的顺序
    - sort()方法
      - 对数组中的元素进行排序
      - 即使是对于纯数字的数组, 使用 sort()排序时, 也会按照 Unicode 编码排序
        - 所以对于数字排序时, 可能得到错误结果
      - 我们可以自己来指定排序的规则
        - 可以在 sort 中传递一个回调函数. 来指定排序规则
        - 回调函数需要定义两个形参
        - 浏览器将分别使用数组中国的元素作为实参去调用回调函数
        - 使用哪个元素调用不确定, 但是肯定的是在数组中 a 一定在 b 的前面
      - 浏览器会根据回调函数的返回值来决定元素的属性
        - 如果返回一个大于 0 的值, 则元素会交换位置
        - 如果返回一个小于 0 的值, 则元素不交换位置
        - 如果返回一个 0, 则认为两个元素相等,也不交换位置
1.  函数对象的方法

    - 当对函数调用 call(), apply()时就是对函数调用, 使用 call, apply 可以指定参数作为 this 传到方法中
    - call()
      - call 方法可以在对象之后, 将参数传到函数, 传递的事实参
    - apply()

      - apply 方法也可以在对象之后,传递参数, 参数是数组

    - 在调用函数的会后, 浏览器都会传递两个隐藏的参数
      1. 函数的上下文对象 this
      1. 封装实参的对象 arguments
         - arguments 是一个类数组对象, 它也可以通过索引来操作数据, 也可以获取长度
         - 在调用函数的时候, 我们传递的实参都会在 arguemnts 中保存
         - arguments.length 可以用来后去实参的长度
         - 我们即使不定义形参,也可以获取到参数
         - 属性 callee, 对应一个函数对象,就是当前正在执行的函数的对象

1.  Date 对象

    - 在 JS 中使用 Date 对象来表示一个时间

1.  包装类
    - 在 JS 中为我们提供了三个包装类, 通过这三个包装类, 可以将基本数据类型的数据转化为对象
      - String()
      - Number()
      - Boolean()
      - 但是注意, 我们在实际应用中不会使用基本数据类型的数据对象, 如果使用基本数据类型的对象, 在做一些比较时, 可能得到一些不可预期的结果
    - 通过包装成对象, 拓展数据的功能
    - 方法和属性只能添加给对象, 不能添加给基本类型数据
    - 当我们对一些基本数据类型的值去调用属性和方法时
    - 浏览器会临时使用包装类将其转化为对象, 然后再调用对象的属性和方法
    - 调用完成之后, 再将其转化为基本数据类型
1.  字符类的操作.
1.  正则表达式
    1. 使用构造函数 RegExp() new 一个对象
    1. 使用 test 方法进行检查
    1. 使用字面量创建 let 变量 = /正则表达式/匹配模式
